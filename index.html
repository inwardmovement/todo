<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="repository" content="https://github.com/inwardmovement/todo" />
    <link rel="manifest" href="manifest.json" />
    <link rel="icon" type="image/png" href="/icons/icon-32.png" />
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <style>
      /* BEGIN RESET */
      *,
      ::after,
      ::before,
      ::backdrop,
      ::file-selector-button {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        border: 0 solid;
      }

      html,
      :host {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        tab-size: 4;
        font-family: --theme(
          --default-font-family,
          ui-sans-serif,
          system-ui,
          sans-serif,
          "Apple Color Emoji",
          "Segoe UI Emoji",
          "Segoe UI Symbol",
          "Noto Color Emoji"
        );
        font-feature-settings: --theme(--default-font-feature-settings, normal);
        font-variation-settings: --theme(
          --default-font-variation-settings,
          normal
        );
        -webkit-tap-highlight-color: transparent;
      }

      ol,
      ul,
      menu {
        list-style: none;
      }

      button,
      input,
      select,
      optgroup,
      textarea,
      ::file-selector-button {
        font: inherit;
        font-feature-settings: inherit;
        font-variation-settings: inherit;
        letter-spacing: inherit;
        color: inherit;
        border-radius: 0;
        background-color: transparent;
        opacity: 1;
      }
      /* END RESET */

      :root {
        --bg: white;
        --fg: black;
      }

      body {
        height: 100vh;
        cursor: default;
        background-color: var(--bg);
        color: var(--fg);
      }

      ul {
        padding-bottom: 24px;
      }

      li {
        padding-left: 6px;
        white-space: pre;
        text-wrap: wrap;
      }

      .space {
        height: 24px;
      }

      input {
        position: fixed;
        bottom: 0;
        padding-left: 6px;
        background-color: var(--bg);
        outline: none;
        cursor: default;
        z-index: -1;
        text-wrap: wrap;
      }

      input.empty {
        caret-color: transparent;
      }

      .sortable-ghost {
        color: var(--bg);
      }

      .edit-input {
        position: static;
        width: 100%;
        padding-left: 0;
        z-index: auto;
      }
    </style>
    <script>
      let todos = [];
      let isDragging = false;
      let isEditing = false;
      let sortable = null;

      // Système d'historique pour undo/redo
      const history = {
        undoStack: [],
        redoStack: [],
      };

      // Enregistrer une action dans l'historique
      function recordAction(action) {
        history.undoStack.push(action);
        history.redoStack = [];
      }

      // Annuler la dernière action
      function undo() {
        if (history.undoStack.length === 0) return;

        const action = history.undoStack.pop();
        history.redoStack.push(action);

        switch (action.type) {
          case "ADD_TODO":
            // Annuler un ajout = supprimer l'élément
            todos.splice(action.index, 1);
            break;
          case "REMOVE_TODO":
            // Annuler une suppression = remettre l'élément
            todos.splice(action.index, 0, action.text);
            break;
          case "REORDER":
            // Annuler un réordonnancement = revenir à l'ancienne position
            const item = todos.splice(action.newIndex, 1)[0];
            todos.splice(action.oldIndex, 0, item);
            break;
          case "REPLACE_ALL":
            // Annuler un remplacement complet = restaurer l'ancienne liste
            todos = [...action.previousTodos];
            break;
          case "RENAME_TODO":
            // Annuler un renommage = remettre l'ancien texte
            todos[action.index] = action.oldText;
            break;
        }

        render();
        input.focus();
      }

      // Rétablir la dernière action annulée
      function redo() {
        if (history.redoStack.length === 0) return;

        const action = history.redoStack.pop();
        history.undoStack.push(action);

        switch (action.type) {
          case "ADD_TODO":
            // Refaire un ajout = ajouter l'élément
            todos.splice(action.index, 0, action.text);
            break;
          case "REMOVE_TODO":
            // Refaire une suppression = supprimer l'élément
            todos.splice(action.index, 1);
            break;
          case "REORDER":
            // Refaire un réordonnancement = remettre à la nouvelle position
            const item = todos.splice(action.oldIndex, 1)[0];
            todos.splice(action.newIndex, 0, item);
            break;
          case "REPLACE_ALL":
            // Refaire un remplacement complet = appliquer la nouvelle liste
            todos = [...action.newTodos];
            break;
          case "RENAME_TODO":
            // Refaire un renommage = remettre le nouveau texte
            todos[action.index] = action.newText;
            break;
        }

        render();
        input.focus();
      }

      // Initialisation
      document.addEventListener("DOMContentLoaded", () => {
        input = document.getElementById("todoInput");
        list = document.getElementById("todoList");
        body = document.querySelector("body");

        input.focus();

        sortable = Sortable.create(list, {
          filter: ".edit-input",
          preventOnFilter: true,
          onStart: function () {
            isDragging = true;
            input.blur();
          },
          onEnd: function (evt) {
            // Réorganiser le tableau todos en fonction du nouvel ordre
            const movedItem = todos.splice(evt.oldIndex, 1)[0];
            todos.splice(evt.newIndex, 0, movedItem);

            // Enregistrer le réordonnancement dans l'historique
            if (evt.oldIndex !== evt.newIndex) {
              recordAction({
                type: "REORDER",
                oldIndex: evt.oldIndex,
                newIndex: evt.newIndex,
              });
            }

            // Rendre à nouveau la liste pour mettre à jour les écouteurs d'événements
            render();

            // Double requestAnimationFrame pour s'assurer que tout est terminé
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                isDragging = false;
                input.focus();
              });
            });
          },
        });

        // Ajuster le z-index et le caret en fonction du contenu de l'input
        function updateInputZIndex() {
          if (input.value !== "") {
            input.style.zIndex = "0";
            input.classList.remove("empty");
          } else {
            input.style.zIndex = "-1";
            input.classList.add("empty");
          }
        }

        // Écouter les changements de contenu
        input.addEventListener("input", updateInputZIndex);

        // Initialiser le z-index au chargement
        updateInputZIndex();

        // Quand l'input perd le focus, le récupérer immédiatement
        input.addEventListener("blur", () => {
          if (!isDragging && !isEditing) {
            setTimeout(() => input.focus(), 0);
          }
        });

        // Quand la fenêtre devient active
        window.addEventListener("focus", () => {
          if (!isDragging && !isEditing) {
            input.focus();
          }
        });

        // Click n'importe où ramène le focus
        body.onclick = () => {
          if (!isDragging && !isEditing) {
            input.focus();
          }
        };

        // Ajouter un élément avec Enter
        input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
            const value = input.value || " ";
            addTodo(value);
            input.value = "";
            updateInputZIndex();
            input.focus();
          }
        });

        // Vider l'input avec Échap
        input.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            input.value = "";
            updateInputZIndex();
            input.focus();
          }
        });

        // Copier la liste (Alt + C)
        document.addEventListener("keydown", async (e) => {
          if (e.altKey && e.key === "c") {
            e.preventDefault();
            await copyToClipboard();
          }
        });

        // Coller la liste (Alt + V)
        document.addEventListener("keydown", async (e) => {
          if (e.altKey && e.key === "v") {
            e.preventDefault();
            await pasteFromClipboard();
          }
        });

        // Annuler (Ctrl + Z)
        document.addEventListener("keydown", (e) => {
          if (e.ctrlKey && e.key === "z") {
            e.preventDefault();
            undo();
          }
        });

        // Rétablir (Ctrl + Y)
        document.addEventListener("keydown", (e) => {
          if (e.ctrlKey && e.key === "y") {
            e.preventDefault();
            redo();
          }
        });

        // Fermer la fenêtre avec le clic du milieu (molette)
        document.addEventListener("auxclick", (e) => {
          if (e.button === 1) {
            e.preventDefault();
            window.close();
          }
        });
      });

      // Ajouter un todo
      function addTodo(text) {
        const index = todos.length;
        todos.push(text);
        recordAction({ type: "ADD_TODO", text, index });
        render();
        input.focus();
      }

      // Supprimer un todo
      function removeTodo(index) {
        const text = todos[index];
        todos.splice(index, 1);
        recordAction({ type: "REMOVE_TODO", text, index });
        render();
        input.focus();
      }

      // Renommer un todo
      function renameTodo(index, newText) {
        const oldText = todos[index];
        if (newText !== oldText) {
          todos[index] = newText;
          recordAction({ type: "RENAME_TODO", index, oldText, newText });
        }
        render();
        input.focus();
      }

      // Activer le mode édition pour un todo
      function startEditing(index, liElement) {
        isEditing = true;
        sortable.option("disabled", true);
        const currentText = todos[index];

        // Créer l'input d'édition
        const editInput = document.createElement("input");
        editInput.type = "text";
        editInput.value = currentText === " " ? "" : currentText;
        editInput.className = "edit-input";
        editInput.autocomplete = "off";
        editInput.spellcheck = false;

        // Remplacer le li par l'input
        liElement.textContent = "";
        liElement.appendChild(editInput);

        // Focus et sélectionner tout le texte
        editInput.focus();
        editInput.select();

        // Empêcher les événements de propager (pour ne pas supprimer l'élément ou déclencher le drag)
        editInput.addEventListener("click", (e) => {
          e.stopPropagation();
        });
        editInput.addEventListener("mousedown", (e) => {
          e.stopPropagation();
        });

        // Valider avec Entrée
        editInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            isEditing = false;
            sortable.option("disabled", false);
            const newText = editInput.value || " ";
            renameTodo(index, newText);
          } else if (e.key === "Escape") {
            // Annuler avec Échap
            e.preventDefault();
            isEditing = false;
            sortable.option("disabled", false);
            render();
            input.focus();
          }
        });

        // Annuler si on perd le focus
        editInput.addEventListener("blur", () => {
          isEditing = false;
          sortable.option("disabled", false);
          render();
          input.focus();
        });
      }

      // Render la liste
      function render() {
        list.innerHTML = "";
        todos.forEach((todo, index) => {
          const li = document.createElement("li");
          li.textContent = todo;

          // Ajouter la classe "space" si le contenu est un seul espace
          if (todo === " ") {
            li.classList.add("space");
          }

          // Click pour supprimer (sauf en mode édition)
          li.addEventListener("click", (e) => {
            if (!isEditing) {
              removeTodo(index);
            }
          });

          // Clic droit pour renommer
          li.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            startEditing(index, li);
          });

          list.appendChild(li);
        });
      }

      // Copier la liste au format texte
      async function copyToClipboard() {
        const text = todos.map((todo) => (todo === " " ? "" : todo)).join("\n");

        try {
          await navigator.clipboard.writeText(text);
          console.log("Liste copiée dans le presse-papier");
        } catch (err) {
          console.error("Erreur lors de la copie:", err);
        }
      }

      // Coller la liste depuis le presse-papier
      async function pasteFromClipboard() {
        try {
          const text = await navigator.clipboard.readText();
          const lines = text.split("\n");

          // Sauvegarder l'ancienne liste pour l'historique
          const previousTodos = [...todos];

          // Remplacer la liste existante
          // Transformer les lignes vides (ou contenant uniquement des espaces) en " "
          todos = lines.map((line) => (line.trim() === "" ? " " : line));

          // Enregistrer dans l'historique
          recordAction({
            type: "REPLACE_ALL",
            previousTodos,
            newTodos: [...todos],
          });

          render();
          console.log("Liste importée depuis le presse-papier");
        } catch (err) {
          console.error("Erreur lors du collage:", err);
        }
      }
    </script>
    <title>To-do</title>
  </head>
  <body>
    <ul id="todoList"></ul>
    <input type="text" id="todoInput" autocomplete="off" spellcheck="false" />
  </body>
</html>
